// Copyright 2011 Vadim Vygonets. All rights reserved.
// Use of this source code is governed by the Bugroff
// license that can be found in the LICENSE file.

package forth

// Memory positions
const (
	A_state	= 0xd0

	A_numberTib0 = 0xe0
	A_tib0 = 0xe4
	A_toIn0 = 0xe8
	A_sourceID = 0xec
	A_defaultSource = 0xfe00

	A_here = 0x0100
	A_dicthead = 0x0114
	A_base = 0x128
	A_pad = 0xfd00
	A_funcpad = A_pad - 8
)

var kernel = []byte{
	0x00, 0x00, 0x00, 0x02,  // (abort)
	0x40, 0x00, 0x00, 0x00,  // 0
	0x40, 0x00, byte(A_sourceID >> 8), byte(A_sourceID & 0xff),
	0x00, 0x00, 0x00, 0x11,  // !
	// 0x10
	0x00, 0x00, 0x00, 0x03,  // (quit)
	0x00, 0x00, 0x00, 0x42,  // refill
	0x30, 0x00, 0x00, 0xbc,  // jz eof
	0x10, 0x00, 0x00, 0x40,  // call line processor
	// 0x20
	0x40, 0x00, 0x00, A_state,
	0x00, 0x00, 0x00, 0x10,  // @
	0x00, 0x00, 0x00, 0x22,  // 0=
	0x30, 0x00, 0x00, 0x10,  // jz to QUIT
	// 0x30
	0x40, 0x00, 0x00, 0xc0,  // s" ok: "
	0x40, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x48,  // type
	0x20, 0x00, 0x00, 0x10,  // jmp to QUIT
	// 0x40
	// line processor
	0x00, 0x00, 0x00, 0x44,  // parse-word
	0x50, 0x00, 0x01, 0x00,  // dup
	0x30, 0x00, 0x00, 0x98,  // jz drops
	0x00, 0x00, 0x00, 0x4a,  // (find)
	// 0x50
	0x00, 0x00, 0x00, 0x09,  // ?dup
	0x30, 0x00, 0x00, 0x7c,  // jz to trynumber
	0x00, 0x00, 0x00, 0x2d,  // 1-
	0x30, 0x00, 0x00, 0x74,  // jz to exec
	// 0x60
	0x40, 0x00, 0x00, A_state,
	0x00, 0x00, 0x00, 0x10,  // @
	0x30, 0x00, 0x00, 0x74,  // jz to exec
	0x00, 0x00, 0x00, 0x4c,  // compile,
	// 0x70
	0x20, 0x00, 0x00, 0x40,  // jmp to parse-word
	0x00, 0x00, 0x00, 0x49,  // execute
	0x20, 0x00, 0x00, 0x40,  // jmp to parse-word
	0x00, 0x00, 0x00, 0x4b,  // trynumber
	// 0x80
	0x30, 0x00, 0x00, 0xa0,  // jz notfound
	0x40, 0x00, 0x00, A_state,
	0x00, 0x00, 0x00, 0x10,  // @
	0x30, 0x00, 0x00, 0x40,  // jz to parse-word
	// 0x90
	0x00, 0x00, 0x00, 0x4d,  // literal
	0x20, 0x00, 0x00, 0x40,  // jmp to parse-word
	0x00, 0x00, 0x00, 0x08,  // 2drop
	0x00, 0x00, 0x00, 0x01,  // exit
	// 0xa0
	0x40, 0x00, 0x00, 0x0a,  // cr
	0x00, 0x00, 0x00, 0x41,  // emit
	0x00, 0x00, 0x00, 0x48,  // type
	0x40, 0x00, 0x00, 0xc4,  // s"  ?  "
	// 0xb0
	0x40, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x48,  // type
	0x20, 0x00, 0x00, 0x00,  // jmp to ABORT
	0x00, 0x00, 0x00, 0x51,  // eof
	// 0xc0
	'o', 'k', ':', ' ',      // "ok: "
	' ', '?', ' ', ' ',      // " ?  "
	0, 0, 0, 0,    //  LOOK !!!  FREE SPACE !!!
	0, 0, 0, 0,    //  LOOK !!!  FREE SPACE !!!
	// 0xd0
	0, 0, 0, 0, // state
	// source -1 (evaluate)
	0, 0, 0, 0, // "#tib"
	0, 0, 0, 0, // "tib"
	0, 0, 0, 0, // >in
	// source 0 (input)
	// 0xe0
	0, 0, 0, 0, // #tib
	0, 0, 0, 0, // tib
	0, 0, 0, 0, // >in
	0, 0, 0, 0, // source-id???
	// dict: struct
	//   flags|namelen	byte
	//   name		[1-31]byte
	//   align?		[0-3]byte?
	//   prev		Cell
	//   codeword | 0	Cell
	//   data?		[]Cell
	// flags:
	//   0x80		immediate
	//   0x40		variable
	//   0x20		unused/reserved
	//   0x1f		len(name)
	// 0xf0
	0x44, 'h', 'e', 'r',
	'e', 0 , 0, 0,
	0x00, 0x00, 0x00, 0x00,  // last in wordlist
	0x00, 0x00, 0x00, 0x10,  // DOES> @
	// 0x0100
	0x00, 0x00, 0x04, 0x78,  // 0x0100: here
	0x47, '(', 'w', 'o',
	'r', 'd', 's', ')',
	0x00, 0x00, 0x00, 0xf0,
	// 0x0110
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x54,  // 0x0114: (words) a.k.a. A_dicthead
	0x44, 'b', 'a', 's',
	'e', 0 , 0, 0,
	// 0x0120
	0x00, 0x00, 0x01, 0x04,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0a, // 0x0128: base
	// quit ( R: j*x -- )
	0x04, 'q', 'u', 'i',
	// 0x0130
	't', 0, 0, 0,
	0x00, 0x00, 0x01, 0x18,
	0x20, 0x00, 0x00, 0x10,  // jmp 10
	// abort ( i*x -- ) ( R: j*x -- )
	0x05, 'a', 'b', 'o',
	// 0x0140
	'r', 't', 0, 0,
	0x00, 0x00, 0x01, 0x2c,
	0x20, 0x00, 0x00, 0x00,  // jmp 0
	// ] ( -- )
	0x41, ']', 0, 0,
	// 0x0150
	0x00, 0x00, 0x01, 0x3c,
	0x10, 0x00, 0x01, 0x5c,
	0xff, 0xff, 0xff, 0xff,  // TRUE
	0x00, 0x00, 0x00, 0x10,  // @
	// 0x0160
	0x40, 0x00, 0x00, A_state,
	0x20, 0x00, 0x01, 0xec,  // jmp to ! exit
	// [ ( -- )  immediate (variable, too)
	// good luck compiling this one
	0xc1, '[', 0, 0,
	0x00, 0x00, 0x01, 0x4c,
	// 0x0170
	0x10, 0x00, 0x01, 0x5c,
	0x00, 0x00, 0x00, 0x00,  // FALSE
	// , ( x -- )
	0x01, ',', 0, 0,
	0x00, 0x00, 0x01, 0x68,
	// 0x0180
	0x10, 0x00, 0x01, 0x84,
	0x40, 0x00, byte(A_here >> 8), byte(A_here & 0xff),
	0x00, 0x00, 0x00, 0x10,  // @
	0x00, 0x00, 0x00, 0x11,  // !
	// 0x0190
	0x40, 0x00, 0x00, 0x04,  // 4
	0x40, 0x00, byte(A_here >> 8), byte(A_here & 0xff),
	0x00, 0x00, 0x00, 0x16,  // +!
	0x00, 0x00, 0x00, 0x01,  // exit
	// 0x01a0
	// c, ( char -- )
	0x02, 'c', ',', 0,
	0x00, 0x00, 0x01, 0x78,
	0x10, 0x00, 0x01, 0xac,
	0x40, 0x00, byte(A_here >> 8), byte(A_here & 0xff),
	// 0x01b0
	0x00, 0x00, 0x00, 0x10,  // @
	0x00, 0x00, 0x00, 0x13,  // c!
	0x40, 0x00, 0x00, 0x01,  // 1
	0x20, 0x00, 0x01, 0x94,  // jmp to (here) +! exit
	// 0x01c0
	// align ( -- )
	0x05, 'a', 'l', 'i',
	'g', 'n', 0, 0,
	0x00, 0x00, 0x01, 0xa0,
	0x10, 0x00, 0x01, 0xd0,
	// 0x01d0
	0x40, 0x00, byte(A_here >> 8), byte(A_here & 0xff),
	0x00, 0x00, 0x00, 0x10,  // @
	0x40, 0x00, 0x00, 0x03,  // 3
	0x00, 0x00, 0x00, 0x2e,  // +
	// 0x01e0
	0x41, 0xff, 0xff, 0xfc,  // 3 negate
	0x00, 0x00, 0x00, 0x25,  // and
	0x40, 0x00, byte(A_here >> 8), byte(A_here & 0xff),
	0x00, 0x00, 0x00, 0x11,  // !
	// 0x01f0
	0x00, 0x00, 0x00, 0x01,  // exit
	// ' ( "<spaces>name" -- xt )
	0x01, '\'', 0, 0,
	0x00, 0x00, 0x01, 0xc0,
	0x10, 0x00, 0x02, 0x00,
	// 0x0200
	0x00, 0x00, 0x00, 0x44,  // parse-word
	0x00, 0x00, 0x00, 0x4a,  // (find)
	0x30, 0x00, 0x00, 0x8c,  // jz notfound
	0x00, 0x00, 0x00, 0x01,  // exit
	// 0x0210
	// (s,) ( addr u -- )
	0x04, '(', 's', ',',
	')', 0, 0, 0,
	0x00, 0x00, 0x01, 0xf4,
	0x10, 0x00, 0x02, 0x20,
	// 0x0220
	0x50, 0x00, 0x01, 0x00,  // ( begin ) dup
	0x30, 0x00, 0x02, 0x48,  // ( while )	\ jz end
	0x50, 0x00, 0x01, 0x01,  // over
	0x00, 0x00, 0x00, 0x12,  // c@
	// 0x0230
	0x10, 0x00, 0x01, 0xac,  // c,
	0x50, 0x02, 0x01, 0x01,  // swap
	0x00, 0x00, 0x00, 0x2c,  // 1+
	0x50, 0x02, 0x01, 0x01,  // swap
	// 0x0240
	0x00, 0x00, 0x00, 0x2d,  // 1-
	0x20, 0x00, 0x02, 0x20,  // ( repeat )	\ jmp start
	0x00, 0x00, 0x00, 0x08,  // 2drop
	0x00, 0x00, 0x00, 0x01,  // exit
	// 0x0250
	// literal  Compilation: ( x -- )  Run-time: ( -- x )  immediate
	0x87, 'l', 'i', 't',
	'e', 'r', 'a', 'l',
	0x00, 0x00, 0x02, 0x10,
	0x10, 0x00, 0x02, 0x60,
	// 0x0260
	0x40, 0x00, 0x00, 0x07,  // 7
	0x00, 0x00, 0x00, 0x0c,  // >r
	0x40, 0x00, 0x00, 0x01,  // 1
	0x00, 0x00, 0x00, 0x0e,  // r@
	// 0x0270
	0x00, 0x00, 0x00, 0x28,  // lshift
	0x00, 0x00, 0x00, 0x2d,  // 1-
	0x50, 0x00, 0x01, 0x01,  // over
	0x00, 0x00, 0x00, 0x25,  // and
	// 0x0280
	0x30, 0x00, 0x02, 0x98,  // jz (handle)
	0x00, 0x00, 0x00, 0x0d,  // r>
	0x00, 0x00, 0x00, 0x09,  // ?dup
	0x30, 0x00, 0x02, 0xc0,  // jz long (after rdrop)
	// 0x0290
	0x00, 0x00, 0x00, 0x2d,  // 1-
	0x20, 0x00, 0x02, 0x64,  // jmp start
	// i low bits of n are 0
	0x4f, 0xfe, 0x00, 0x00,  // ff000000
	0x00, 0x00, 0x00, 0x0e,  // r@
	// 0x02a0
	0x00, 0x00, 0x00, 0x28,  // lshift
	0x50, 0x00, 0x02, 0x00,  // 2dup
	0x00, 0x00, 0x00, 0x25,  // and
	0x00, 0x00, 0x00, 0x09,  // ?dup
	// 0x02b0
	0x30, 0x00, 0x02, 0xf8,  // jz drop+short
	0x00, 0x00, 0x00, 0x27,  // xor    \ = 0=
	0x30, 0x00, 0x02, 0xfc,  // jz short
	0x00, 0x00, 0x00, 0x0f,  // rdrop  \ unloop
	// 0x02c0
	// long form
	0x50, 0x00, 0x01, 0x00,  // dup
	0x40, 0xff, 0xff, 0xff,  // 00ffffff
	0x00, 0x00, 0x00, 0x25,  // and
	0x4e, 0x80, 0x00, 0x00,  // 40000000
	// 0x02d0
	0x00, 0x00, 0x00, 0x26,  // or
	0x10, 0x00, 0x01, 0x84,  // ,
	0x40, 0x00, 0x00, 0x07,  // 7
	0x00, 0x00, 0x00, 0x29,  // rshift
	// 0x02e0
	0x4e, 0x9c, 0x00, 0x00,  // 4e000000
	0x00, 0x00, 0x00, 0x26,  // or
	0x10, 0x00, 0x01, 0x84,  // ,
	0x40, 0x00, 0x00, 0x26,  // 00000026  \ or
	// 0x02f0
	0x10, 0x00, 0x01, 0x84,  // ,
	0x00, 0x00, 0x00, 0x01,  // exit
	// short form
	0x00, 0x00, 0x00, 0x07,  // drop
	0x00, 0x00, 0x00, 0x0e,  // r@
	// 0x0300
	0x00, 0x00, 0x00, 0x29,  // rshift
	0x4f, 0xfc, 0x00, 0x00,  // fe000000
	0x00, 0x00, 0x00, 0x24,  // invert  \ 01ffffff
	0x00, 0x00, 0x00, 0x25,  // and
	// 0x0310
	0x00, 0x00, 0x00, 0x0d,  // r>
	0x40, 0x00, 0x00, 0x19,  // 25 (decimal)
	0x00, 0x00, 0x00, 0x28,  // lshift
	0x00, 0x00, 0x00, 0x26,  // or
	// 0x0320
	0x4e, 0x80, 0x00, 0x00,  // 40000000
	0x00, 0x00, 0x00, 0x26,  // or
	0x10, 0x00, 0x01, 0x84,  // ,
	0x00, 0x00, 0x00, 0x01,  // exit
	// 0x0330
	// compile,  Execution: ( xt -- )
	0x08, 'c', 'o', 'm',
	'p', 'i', 'l', 'e',
	',', 0, 0, 0,
	0x00, 0x00, 0x02, 0x50,
	// 0x0340
	0x10, 0x00, 0x03, 0x44,
	0x50, 0x00, 0x01, 0x00,  // dup
	0x40, 0x00, 0x00, 0x01,  // 00000001
	0x00, 0x00, 0x00, 0x25,  // and
	// 0x0350
	0x30, 0x00, 0x03, 0x64,  // ( if )  \ jz down
	0x50, 0x00, 0x01, 0x00,  // dup
	0x10, 0x00, 0x04, 0x64,  // aligned
	0x10, 0x00, 0x02, 0x60,  // ( postpone :) literal
	// 0x0360
	0x00, 0x00, 0x00, 0x2d,  // 1-
	0x00, 0x00, 0x00, 0x10,  // ( then ) @
	0x00, 0x00, 0x00, 0x09,  // ?dup
	0x30, 0x00, 0x03, 0x2c,  // \ jz to exit
	// 0x0370
	0x20, 0x00, 0x01, 0x84,  // jmp ,
	// dup ( x -- x x )
	0x03, 'd', 'u', 'p',
	0x00, 0x00, 0x03, 0x30,
	0x50, 0x00, 0x01, 0x00,  // pick 1 0
	// 0x0380
	// over ( x1 x2 -- x1 x2 x1 )
	0x04, 'o', 'v', 'e',
	'r', 0, 0, 0,
	0x00, 0x00, 0x03, 0x74,
	0x50, 0x00, 0x01, 0x01,  // pick 1 1
	// 0x0390
	// swap ( x1 x2 -- x2 x1 )
	0x04, 's', 'w', 'a',
	'p', 0, 0, 0,
	0x00, 0x00, 0x03, 0x80,
	0x50, 0x02, 0x01, 0x01,  // roll 1 1
	// 0x03a0
	// rot ( x1 x2 x3 -- x2 x3 x1 )
	0x03, 'r', 'o', 't',
	0x00, 0x00, 0x03, 0x90,
	0x50, 0x02, 0x01, 0x02,  // roll 1 2
	// -rot ( x1 x2 x3 -- x3 x1 x2 )
	0x04, '-', 'r', 'o',
	// 0x03b0
	't', 0, 0, 0,
	0x00, 0x00, 0x03, 0xa0,
	0x50, 0x02, 0x02, 0x01,  // roll 2 1
	// 2dup ( x1 x2 -- x1 x2 x1 x2 )
	0x04, '2', 'd', 'u',
	// 0x03c0
	'p', 0, 0, 0,
	0x00, 0x00, 0x03, 0xac,
	0x50, 0x00, 0x02, 0x00,  // pick 2 0
	// 2over ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
	0x05, '2', 'o', 'v',
	// 0x03d0
	'e', 'r', 0, 0,
	0x00, 0x00, 0x03, 0xbc,
	0x50, 0x00, 0x02, 0x02,  // pick 2 2
	// 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
	0x05, '2', 's', 'w',
	// 0x03e0
	'a', 'p', 0, 0,
	0x00, 0x00, 0x03, 0xcc,
	0x50, 0x02, 0x02, 0x02,  // roll 2 2
	// 2rot ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
	0x04, '2', 'r', 'o',
	// 0x03f0
	't', 0, 0, 0,
	0x00, 0x00, 0x03, 0xdc,
	0x50, 0x02, 0x02, 0x04,  // roll 2 4
	// 2-rot ( x1 x2 x3 x4 x5 x6 -- x5 x6 x1 x2 x3 x4 )
	0x05, '2', '-', 'r',
	// 0x0400
	'o', 't', 0, 0,
	0x00, 0x00, 0x03, 0xec,
	0x50, 0x02, 0x04, 0x02,  // roll 4 2
	// evaluate ( i*x c-addr u -- j*x )
	0x08, 'e', 'v', 'a',
	// 0x0410
	'l', 'u', 'a', 't',
	'e', 0, 0, 0,
	0x00, 0x00, 0x03, 0xfc,
	0x10, 0x00, 0x04, 0x20,
	// 0x0420
	0x40, 0x00, 0x00, A_numberTib0 - 12,  // our #tib, tib
	0x00, 0x00, 0x00, 0x14,  // 2!
	0x40, 0x00, 0x00, 0x00,  // 0
	0x40, 0x00, 0x00, A_toIn0 - 12,  // our >in
	// 0x0430
	0x00, 0x00, 0x00, 0x11,  // !
	0x41, 0xff, 0xff, 0xff,  // -1
	0x40, 0x00, 0x00, A_sourceID,  // source-id
	0x00, 0x00, 0x00, 0x11,  // !
	// 0x0440
	0x10, 0x00, 0x00, 0x40,  // call line processor
	0x40, 0x00, 0x00, 0x00,  // -
	0x40, 0x00, 0x00, 0xec,  // source-id
	0x00, 0x00, 0x00, 0x11,  // !
	// 0x0450
	0x00, 0x00, 0x00, 0x01,  // exit
	// aligned ( addr -- a-addr )
	0x07, 'a', 'l', 'i',
	'g', 'n', 'e', 'd',
	0x00, 0x00, 0x04, 0x0c,
	// 0x0460
	0x10, 0x00, 0x04, 0x64,
	0x40, 0x00, 0x00, 0x03,  // 3
	0x00, 0x00, 0x00, 0x2e,  // +
	0x41, 0xff, 0xff, 0xfc,  // 3 negate
	// 0x0470
	0x00, 0x00, 0x00, 0x25,  // and
	0x00, 0x00, 0x00, 0x01,  // exit
	// ...
}

var softcore = `
1 2* 2* 2* 2* base !
here 013a0000 ,
(words) @ , (words) !
here 4 + 10000000 or ,
] here parse-word dup c, (s,) align
(words) @ , here 4 + 10000000 or , ] exit [
: ; [ ' exit (literal) ] compile, (words) ! [ ' [ compile, ]
exit [
dup c@ 80 or over c!
(words) !

: immediate (words) @ dup c@ 80 or swap c! ;

: \ a parse 2drop ; immediate

\ ok, here's a copy of the above:
\ : : here parse-word dup c, (s,) align (words) @ , here 4 + 10000000 or , ] ;
\ : ; postpone exit (words) ! postpone [ ; immediate

\ : literal (literal) ; immediate

\ Assembly
\ : primitive, , ;

\ call, jmp, jz, ( addr -- )
: call, 10000000 or , ;
: jmp,  20000000 or , ;
: jz,   30000000 or , ;

\ literal elsewhere

\ (0101) 0000  0000 00os  00ww wwww  00ff ffff
\ o = operation (0: pick, 1: roll)
\ s = stack (0: data stack, 1: rstack)
\ w = width
\ f = from

\ pick, ( width from -- )
: pick, 50000000 or swap 8 lshift or , ;
: roll, 00020000 or pick, ;
: rpick, 00010000 or pick, ;
: rroll, 00030000 or pick, ;

: if here 0 jz, ; immediate
: then dup @ f0000000 and here 0fffffff and or swap ! ; immediate

: postpone parse-word (find) 1- if
  (literal) [ ' compile, ] literal then compile, ; immediate
\ what is this i don't even

: begin here ; immediate
: again jmp, ; immediate
: until jz, ; immediate
: ahead here 0 jmp, ; immediate

: else postpone ahead swap postpone then ; immediate
: while postpone if swap ; immediate
: repeat postpone again postpone then ; immediate

: 2>r postpone swap postpone >r postpone >r ; immediate
: 2r> postpone r> postpone r> postpone swap ; immediate
: 2r@ postpone r> postpone r@ postpone swap postpone dup postpone >r ; immediate
: 2rdrop postpone rdrop postpone rdrop ; immediate

: cr a emit ;
: stack depth begin ?dup while dup pick . 1- repeat cr ;

: i postpone r@ ; immediate
: (do) postpone begin postpone 2>r ;
: do 0 (do) ; immediate
: ?do 0 postpone 2dup postpone xor postpone if (do) ; immediate
: unloop postpone 2rdrop ; immediate
: loop postpone 2r> postpone 1+ postpone 2dup postpone =
  postpone until
  begin ?dup while postpone then repeat
  postpone 2drop
; immediate

\ fucking leave, how does it normally work?
: leave
   0 begin over while swap >r 1+ repeat
   postpone ahead swap
   begin ?dup while r> swap 1- repeat
; immediate

\ : foo 10 0 ?do i . i 5 = if leave then loop ;

: ['] ' postpone literal ; immediate

: char parse-word drop c@ ;
: [char] char postpone literal ; immediate
: ( [char] ) parse 2drop ; immediate

: cell+ 4 + ;
: cells 2 lshift ;
: >body fffffffc and cell+ ;  \ 1+ aligned

: decode dup 00ffffff and
  over 01000000 and if fe000000 or then
  swap 19 ( that's hex, btw) rshift 7 and lshift ;

: hex 10 base ! ;
: decimal a base ! ;

: bl 20 ;

: <= > 0= ;
: >= < 0= ;

: dumplast (words) @ here over - dump ;

\ Now we have loops and some basics.  time to define a more-real compiler.

: state d0 @ ; \ TODO
: to ' >body state if postpone literal postpone ! else ! then ; immediate
: allot here + aligned to here ;

: source-id ec @ ;
: source e0 source-id c * + 2@ ;
: >in e8 source-id c * + ;

: (scan) ( char xt c-addr c-addr -- c-addr )
   >r >r
   begin 2r@ > while
     2dup r@ c@ swap execute while
     r> 1+ >r repeat then
   2drop r> rdrop
;

: parse ( char "ccc<char>" -- c-addr u )
   source over + >r >in @ +
   over bl = if over swap ['] >= swap r@ (scan) then
   swap 2dup bl = if ['] < else ['] <> then
   swap r> (scan)
   dup source >r -
   dup r> < if 1+ then >in !
   over -
;

: parse-word ( "<spaces>name" -- c-addr u ) bl parse ;

: (:) >r here parse-word dup r> or c, (s,) align (words) @ , ;
: (;) (words) ! ;
: (create) 40 (:) (;) ;
: create (create) 0 , ;
: variable create 0 , ;
: value (create) ['] @ compile, , ;
: : 0 (:) here cell+ call, ] ;
: ; postpone exit (;) postpone [ ; immediate

: skipname dup c@ 1f and + 1+ aligned ;

: nextwordaddr dup c@ 1f and + 1+ aligned @ ;

: does> r> 10000000 or (words) @ skipname cell+ ! ;

: constant value immediate
   does> @ state if postpone literal then ;

: primitive 0 (:) , (;) ;
: alias 0 (:) ' compile, (;) ;

alias char+ 1+

: tolower ( char -- char )
   dup [char] A >= if dup [char] Z <= if
   [ char a char A - ] literal + then then ;

: weq ( addr1 u1 addr2 u2 -- flag )
   2 pick <> if drop 2drop 0 exit then
   swap 0 ?do
     over c@ tolower over c@ tolower <> if unloop 2drop 0 exit then
     swap char+ swap char+ loop
   2drop -1 ;

: (find) ( addr u -- addr u 0 | xt 1 | xt -1 )
   2>r (words) begin @ ?dup while
     dup c@ swap 1+ over 1f and 2dup + aligned -rot 2r@ weq if
       cell+ swap 6 rshift tuck 1 and or
       swap 2 and 1- 2rdrop exit then
     nip repeat
   2r> 0
;

decimal
`
